<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Family Tree – Atualizado</title>
  <style>
    body { margin: 0; }
    canvas {
      background-color: #f0f0f0;
      display: block;
      margin: 0 auto;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.4);
    }
    .modal-content {
      background-color: #fff;
      margin: 5% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 90%;
      max-width: 400px;
    }
    .modal-close {
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      color: #aaa;
    }
    .modal-close:hover, .modal-close:focus {
      color: black;
      text-decoration: none;
    }
    .form-group {
      margin-bottom: 10px;
    }
    label {
      display: block;
      font-weight: bold;
      margin-bottom: 4px;
    }
    input, select {
      width: 100%;
      padding: 6px;
      box-sizing: border-box;
      margin-bottom: 4px;
    }
    .btn {
      padding: 8px 16px;
      border: none;
      cursor: pointer;
      font-size: 14px;
    }
    .btn-save {
      background-color: #28a745;
      color: #fff;
      margin-right: 10px;
    }
    .btn-cancel {
      background-color: #dc3545;
      color: #fff;
    }
  </style>
</head>
<body>
  <canvas id="meuCanvas" width="1200" height="800"></canvas>
  <!-- Modal para adição de novo membro -->
  <div id="modal-adicionar" class="modal">
    <div class="modal-content">
      <span id="modal-adicionar-fechar" class="modal-close">&times;</span>
      <h2>Adicionar Novo Membro</h2>
      <div class="form-group">
        <label for="entradaNome">Nome Completo</label>
        <input type="text" id="entradaNome" placeholder="Nome e sobrenome" />
      </div>
      <div class="form-group">
        <label for="entradaNascimento">Nascimento</label>
        <input type="text" id="entradaNascimento" placeholder="dd/mm/aaaa" />
      </div>
      <div class="form-group">
        <label for="entradaGenero">Gênero</label>
        <select id="entradaGenero">
          <option value="Masculino">Masculino</option>
          <option value="Feminino">Feminino</option>
          <option value="Outro">Outro</option>
        </select>
      </div>
      <div class="form-group">
        <label for="entradaPais">País</label>
        <input type="text" id="entradaPais" placeholder="Brasil" />
      </div>
      <div class="form-group">
        <label for="entradaParentesco">Parentesco</label>
        <select id="entradaParentesco" disabled></select>
      </div>
      <button class="btn btn-save" id="botaoAdicionarSalvar">Salvar alterações</button>
      <button class="btn btn-cancel" id="botaoAdicionarCancelar">Cancelar</button>
    </div>
  </div>

  <script>
    // Variáveis globais e configuração
    let visao = { deslocamentoX: 0, deslocamentoY: 0, escala: 1 };
    let membros = [];
    let contadorMembros = 1;
    const gridSize = 20; // Tamanho do grid para snap-to-grid

    // Função para gerar IDs únicos
    function gerarUUID() {
      return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11)
        .replace(/[018]/g, c =>
          (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
        );
    }

    // Cria um novo membro
    function criarMembro(x, y, tamanho) {
      return {
        id: gerarUUID(),
        nome: "Novo Membro " + contadorMembros++,
        dataNascimento: null,
        genero: null,
        pais: null,
        grauParentesco: null,
        posicaoTela: { x: x, y: y, tamanho: tamanho },
        // Para permitir múltiplas adições de descendentes para "primo", essa flag não será definida para ele.
        temDescendente: false,
        conexoes: [],
        criadoEm: new Date().toISOString(),
        atualizadoEm: new Date().toISOString()
      };
    }

    function salvarEstado() {
      const estado = { visao, membros, contadorMembros };
      localStorage.setItem("estadoArvoreFamiliar", JSON.stringify(estado));
    }

    function carregarEstado() {
      const salvo = localStorage.getItem("estadoArvoreFamiliar");
      if (salvo) {
        const est = JSON.parse(salvo);
        visao = est.visao;
        membros = est.membros;
        contadorMembros = est.contadorMembros;
      } else {
        // Primeiro membro: "Eu"
        const inicial = criarMembro(350, 250, 100);
        inicial.id = "00000000-0000-0000-0000-000000000000";
        inicial.nome = "Eu";
        inicial.grauParentesco = "Eu";
        membros.push(inicial);
      }
    }

    // Hierarquias
    const linhaPai = ["pai", "avô", "bisavô", "trisavô", "tetravô", "pentavô", "hexavô"];
    const linhaFilho = ["filho", "neto", "bisneto", "tataraneto"];

    // Determina o próximo grau baseado na direção e no grau atual
    function obterParentescoAutomatico(membroOrigem, direcao) {
      const pk = membroOrigem.grauParentesco || "Eu";
      if (direcao === "topo") {
        if (pk.toLowerCase() === "tio") return "avô";
        if (pk.toLowerCase() === "primo") return "tio"; // Para primo, o ancestral superior é "tio"
        if (pk.toLowerCase() === "irmao") return "irmao"; // Irmão permanece irmão
        let idx = linhaPai.indexOf(pk.toLowerCase());
        if (pk === "Eu" || idx === -1) return linhaPai[0]; // "pai"
        if (idx < linhaPai.length - 1) return linhaPai[idx + 1];
        return linhaPai[linhaPai.length - 1];
      } else if (direcao === "baixo") {
        let idx = linhaFilho.indexOf(pk.toLowerCase());
        // Se o grau não está na hierarquia de descendentes (ex.: primo, irmao), retorna "filho"
        if (idx === -1) return linhaFilho[0];
        if (idx < linhaFilho.length - 1) return linhaFilho[idx + 1];
        return linhaFilho[linhaFilho.length - 1];
      } else if (direcao === "esquerda") {
        if (pk.toLowerCase() === "eu" || pk.toLowerCase() === "irmao") return "irmao";
        return "tio";
      } else if (direcao === "direita") {
        if (pk.toLowerCase() === "eu" || pk.toLowerCase() === "primo") return "primo";
        return "tio";
      }
      return "outro";
    }

    function temPaiOuMae(membro) {
      return membro.conexoes.some(con => 
        con.tipoLink.toLowerCase() === "pai" || con.tipoLink.toLowerCase() === "mae"
      );
    }

    // Para membros que não são "Eu", verifica se já há conexão acima (topo)
    function jaTemConexaoAcima(membro) {
      if (membro.grauParentesco.toLowerCase() === "eu") return false;
      return membro.conexoes.some(con => con.direcao === "topo");
    }

    function compartilhaParentesComOutro(membro) {
      if (membro.grauParentesco === "Eu") return false;
      const conexoesAncestrais = membro.conexoes.filter(con => linhaPai.includes(con.tipoLink.toLowerCase()));
      if (conexoesAncestrais.length === 0) return false;
      for (let conAnc of conexoesAncestrais) {
        const idAnc = conAnc.idDestino;
        let cont = 0;
        for (let outro of membros) {
          if (outro.somenteLink) continue;
          const c2 = outro.conexoes.filter(con => 
            linhaPai.includes(con.tipoLink.toLowerCase()) && con.idDestino === idAnc
          );
          if (c2.length > 0) cont++;
        }
        if (cont >= 2) return true;
      }
      return false;
    }

    // Elementos do modal
    const modalAdicionar = document.getElementById("modal-adicionar");
    const modalAdicionarFechar = document.getElementById("modal-adicionar-fechar");
    const entradaNome = document.getElementById("entradaNome");
    const entradaNascimento = document.getElementById("entradaNascimento");
    const entradaGenero = document.getElementById("entradaGenero");
    const entradaPais = document.getElementById("entradaPais");
    const entradaParentesco = document.getElementById("entradaParentesco");
    const botaoAdicionarSalvar = document.getElementById("botaoAdicionarSalvar");
    const botaoAdicionarCancelar = document.getElementById("botaoAdicionarCancelar");

    modalAdicionarFechar.onclick = fecharModalAdicionar;
    botaoAdicionarSalvar.onclick = confirmarAdicionarMembro;
    botaoAdicionarCancelar.onclick = fecharModalAdicionar;

    let membroPendente = null;
    let direcaoPendente = null;

    // Exibe o modal para adicionar um novo membro
    function mostrarModalAdicionar(membroOrigem, direcao) {
      // Se for para adicionar acima e já houver conexão (exceto para "Eu"), não exibe o '+'
      if (direcao === "topo" && membroOrigem.grauParentesco.toLowerCase() !== "eu" && jaTemConexaoAcima(membroOrigem))
        return;
      
      membroPendente = membroOrigem;
      direcaoPendente = direcao;
      entradaNome.value = "";
      entradaNascimento.value = "";
      entradaGenero.value = "Masculino";
      entradaPais.value = "Brasil";
      entradaParentesco.innerHTML = "";
      
      if (direcao === "topo") {
        if (membroOrigem.grauParentesco.toLowerCase() === "tio-avô") {
          let ops = [];
          const bisavosExistentes = membros.filter(m => m.grauParentesco.toLowerCase() === "bisavô" && !m.somenteLink);
          bisavosExistentes.forEach(bv => {
            if (!membroOrigem.conexoes.some(c => c.idDestino === bv.id)) {
              ops.push({ value: "conectar-bisavô-" + bv.id, label: "Conectar com bisavô - " + bv.nome });
            }
          });
          ops.forEach(({ value, label }) => {
            const opt = document.createElement("option");
            opt.value = value;
            opt.textContent = label;
            entradaParentesco.appendChild(opt);
          });
          entradaParentesco.disabled = false;
          modalAdicionar.style.display = "block";
          return;
        }
        if (membroOrigem.grauParentesco.toLowerCase() === "tio") {
          let ops = [];
          const avoExistentes = membros.filter(m => m.grauParentesco.toLowerCase() === "avô" && !m.somenteLink);
          avoExistentes.forEach(avo => {
            if (!membroOrigem.conexoes.some(c => c.idDestino === avo.id)) {
              ops.push({ value: "conectar-avô-" + avo.id, label: "Conectar com avô - " + avo.nome });
            }
          });
          const tiosAvoExistentes = membros.filter(m => m.grauParentesco.toLowerCase() === "tio-avô" && !m.somenteLink);
          tiosAvoExistentes.forEach(ta => {
            if (!membroOrigem.conexoes.some(c => c.idDestino === ta.id)) {
              ops.push({ value: "conectar-tioavô-" + ta.id, label: "Conectar com tio-avô - " + ta.nome });
            }
          });
          ops.push({ value: "criar-tioavô", label: "Criar novo tio-avô" });
          ops.forEach(({ value, label }) => {
            const opt = document.createElement("option");
            opt.value = value;
            opt.textContent = label;
            entradaParentesco.appendChild(opt);
          });
          entradaParentesco.disabled = false;
          modalAdicionar.style.display = "block";
          return;
        }
        if (membroOrigem.grauParentesco.toLowerCase() === "primo") {
          // Para "primo" na direção topo, o próximo grau será "tio"
          const parentescoAuto = "tio";
          const opt = document.createElement("option");
          opt.value = parentescoAuto;
          opt.textContent = parentescoAuto;
          entradaParentesco.appendChild(opt);
          entradaParentesco.disabled = true;
          modalAdicionar.style.display = "block";
          return;
        }
      }
      
      // Para direções que não são "topo" ou para "Eu"
      const parentescoAuto = obterParentescoAutomatico(membroOrigem, direcao);
      const opt = document.createElement("option");
      opt.value = parentescoAuto;
      opt.textContent = parentescoAuto;
      entradaParentesco.appendChild(opt);
      entradaParentesco.disabled = (membroOrigem.grauParentesco.toLowerCase() === "eu") ? false : true;
      modalAdicionar.style.display = "block";
    }

    function fecharModalAdicionar() {
      modalAdicionar.style.display = "none";
      membroPendente = null;
      direcaoPendente = null;
    }

    function confirmarAdicionarMembro() {
      if (!membroPendente || !direcaoPendente) {
        fecharModalAdicionar();
        return;
      }
      const valorSelecionado = entradaParentesco.value;
      if (valorSelecionado.startsWith("conectar-avô-")) {
        const idAvo = valorSelecionado.replace("conectar-avô-", "");
        const avoExistente = membros.find(m => m.id === idAvo);
        if (avoExistente) {
          membroPendente.conexoes.push({
            idDestino: avoExistente.id,
            direcao: direcaoPendente,
            tipoLink: "avô",
            somenteLink: false
          });
        }
        fecharModalAdicionar();
        desenharTudo();
        salvarEstado();
        return;
      }
      if (valorSelecionado.startsWith("conectar-tioavô-")) {
        const idTioAvô = valorSelecionado.replace("conectar-tioavô-", "");
        const tioAvôExistente = membros.find(m => m.id === idTioAvô);
        if (tioAvôExistente) {
          membroPendente.conexoes.push({
            idDestino: tioAvôExistente.id,
            direcao: direcaoPendente,
            tipoLink: "tio-avô",
            somenteLink: false
          });
        }
        fecharModalAdicionar();
        desenharTudo();
        salvarEstado();
        return;
      }
      if (valorSelecionado === "criar-tioavô") {
        criarEConectar("tio-avô");
        return;
      }
      if (valorSelecionado.startsWith("conectar-bisavô-")) {
        const idBisavô = valorSelecionado.replace("conectar-bisavô-", "");
        const bisavôExistente = membros.find(m => m.id === idBisavô);
        if (bisavôExistente) {
          membroPendente.conexoes.push({
            idDestino: bisavôExistente.id,
            direcao: direcaoPendente,
            tipoLink: "bisavô",
            somenteLink: false
          });
        }
        fecharModalAdicionar();
        desenharTudo();
        salvarEstado();
        return;
      }
      if (valorSelecionado.startsWith("conectar-tio-")) {
        const idTio = valorSelecionado.replace("conectar-tio-", "");
        const tioExistente = membros.find(m => m.id === idTio);
        if (tioExistente) {
          membroPendente.conexoes.push({
            idDestino: tioExistente.id,
            direcao: direcaoPendente,
            tipoLink: "tio",
            somenteLink: false
          });
        }
        fecharModalAdicionar();
        desenharTudo();
        salvarEstado();
        return;
      }
      if (valorSelecionado === "criar-tio") {
        criarEConectar("tio");
        return;
      }
      // Para direção "baixo": use a hierarquia de descendentes
      criarEConectar(valorSelecionado);
      function criarEConectar(tipo) {
        const posOrigem = membroPendente.posicaoTela;
        let x = posOrigem.x, y = posOrigem.y, t = posOrigem.tamanho;
        if (direcaoPendente === "topo")    y = posOrigem.y - t;
        if (direcaoPendente === "baixo")   y = posOrigem.y + t;
        if (direcaoPendente === "esquerda") x = posOrigem.x - t;
        if (direcaoPendente === "direita")  x = posOrigem.x + t;
        const novoMembro = criarMembro(x, y, t);
        novoMembro.nome = entradaNome.value || ("Membro " + contadorMembros);
        novoMembro.grauParentesco = tipo;
        membros.push(novoMembro);
        membroPendente.conexoes.push({
          idDestino: novoMembro.id,
          direcao: direcaoPendente,
          tipoLink: tipo,
          somenteLink: false
        });
        // Para descendentes, somente marque temDescendente se o nó não for "primo"
        if(membroPendente.grauParentesco.toLowerCase() !== "primo"){
          membroPendente.temDescendente = true;
        }
        fecharModalAdicionar();
        desenharTudo();
        salvarEstado();
      }
    }

    // Desenho da árvore
    const elementoCanvas = document.getElementById("meuCanvas");
    const contexto = elementoCanvas.getContext("2d");

    function desenharTudo() {
      contexto.clearRect(0, 0, elementoCanvas.width, elementoCanvas.height);
      contexto.save();
      contexto.translate(visao.deslocamentoX, visao.deslocamentoY);
      contexto.scale(visao.escala, visao.escala);
      desenharGrade();
      desenharConexoes();
      desenharMembros();
      contexto.restore();
    }

    function desenharGrade() {
      const tamanhoGrade = gridSize;
      contexto.strokeStyle = "#ccc";
      contexto.lineWidth = 0.5 / visao.escala;
      let esquerda = -visao.deslocamentoX / visao.escala;
      let topo = -visao.deslocamentoY / visao.escala;
      let direita = esquerda + elementoCanvas.width / visao.escala;
      let base = topo + elementoCanvas.height / visao.escala;
      let inicioX = Math.floor(esquerda / tamanhoGrade) * tamanhoGrade;
      let inicioY = Math.floor(topo / tamanhoGrade) * tamanhoGrade;
      for (let x = inicioX; x <= direita; x += tamanhoGrade) {
        contexto.beginPath();
        contexto.moveTo(x, topo);
        contexto.lineTo(x, base);
        contexto.stroke();
      }
      for (let y = inicioY; y <= base; y += tamanhoGrade) {
        contexto.beginPath();
        contexto.moveTo(esquerda, y);
        contexto.lineTo(direita, y);
        contexto.stroke();
      }
    }

    function desenharConexoes() {
      contexto.strokeStyle = "blue";
      contexto.lineWidth = 2 / visao.escala;
      membros.forEach(membro => {
        if (membro.somenteLink) return;
        const posM = membro.posicaoTela;
        membro.conexoes.forEach(con => {
          // Não desenha conexão se o tipo for "irmao" (evita linha horizontal)
          if (con.tipoLink.toLowerCase() === "irmao") return;
          const destino = membros.find(x => x.id === con.idDestino);
          if (!destino) return;
          // Se "Eu" estiver envolvido em conexão com "primo" ou "irmao", não desenha a linha horizontal
          if (
            ((membro.grauParentesco.toLowerCase() === "eu" || destino.grauParentesco.toLowerCase() === "eu") &&
             (con.tipoLink.toLowerCase() === "primo" || con.tipoLink.toLowerCase() === "irmao"))
          ) {
            return;
          }
          const posD = destino.posicaoTela;
          let inicioX, inicioY, fimX, fimY;
          if (con.direcao === "topo") {
            inicioX = posM.x + posM.tamanho / 2;
            inicioY = posM.y;
            fimX = posD.x + posD.tamanho / 2;
            fimY = posD.y + posD.tamanho;
          } else if (con.direcao === "baixo") {
            inicioX = posM.x + posM.tamanho / 2;
            inicioY = posM.y + posM.tamanho;
            fimX = posD.x + posD.tamanho / 2;
            fimY = posD.y;
          } else if (con.direcao === "esquerda") {
            inicioX = posM.x;
            inicioY = posM.y + posM.tamanho / 2;
            fimX = posD.x + posD.tamanho;
            fimY = posD.y + posD.tamanho / 2;
          } else if (con.direcao === "direita") {
            inicioX = posM.x + posM.tamanho;
            inicioY = posM.y + posM.tamanho / 2;
            fimX = posD.x;
            fimY = posD.y + posD.tamanho / 2;
          } else {
            inicioX = posM.x + posM.tamanho / 2;
            inicioY = posM.y + posM.tamanho / 2;
            fimX = posD.x + posD.tamanho / 2;
            fimY = posD.y + posD.tamanho / 2;
          }
          contexto.beginPath();
          contexto.moveTo(inicioX, inicioY);
          contexto.lineTo(fimX, fimY);
          contexto.stroke();
        });
      });
    }

    const distanciaDeslocamento = 20;
    function desenharMais(cx, cy) {
      contexto.save();
      contexto.strokeStyle = "black";
      contexto.lineWidth = 3;
      const r = 10;
      contexto.beginPath();
      contexto.moveTo(cx, cy - r);
      contexto.lineTo(cx, cy + r);
      contexto.stroke();
      contexto.beginPath();
      contexto.moveTo(cx - r, cy);
      contexto.lineTo(cx + r, cy);
      contexto.stroke();
      contexto.restore();
    }

    function desenharMembros() {
      membros.forEach(membro => {
        if (membro.somenteLink) return;
        const pos = membro.posicaoTela;
        contexto.fillStyle = "#4CAF50";
        contexto.fillRect(pos.x, pos.y, pos.tamanho, pos.tamanho);
        const metade = pos.tamanho / 2;
        
        // Sinal superior:
        // Para "Eu": sempre exibe
        // Para outros, se não for "irmao" e não tiver conexão 'topo' e não for último grau de linhaPai, exibe
        if (
          (membro.grauParentesco.toLowerCase() === "eu") ||
          (membro.grauParentesco.toLowerCase() !== "irmao" &&
           !membro.conexoes.some(con => con.direcao === "topo") &&
           membro.grauParentesco.toLowerCase() !== linhaPai[linhaPai.length - 1])
        ) {
          desenharMais(pos.x + metade, pos.y - distanciaDeslocamento);
        }
        
        // Sinal inferior:
        // Exibe para todos EXCETO se o membro for "neto"
        if (membro.grauParentesco.toLowerCase() !== "neto") {
          desenharMais(pos.x + metade, pos.y + pos.tamanho + distanciaDeslocamento);
        }
        
        // Sinais laterais: somente para "Eu"
        if (membro.grauParentesco.toLowerCase() === "eu") {
          desenharMais(pos.x - distanciaDeslocamento, pos.y + metade);
          desenharMais(pos.x + pos.tamanho + distanciaDeslocamento, pos.y + metade);
        }
        
        desenharTextoMembro(membro);
      });
    }

    function desenharTextoMembro(membro) {
      const pos = membro.posicaoTela;
      contexto.fillStyle = "white";
      contexto.font = `bold ${12 / visao.escala}px Arial`;
      contexto.fillText("editar", pos.x + pos.tamanho - 50, pos.y + pos.tamanho - 5);
      contexto.fillStyle = "black";
      contexto.font = `${12 / visao.escala}px Arial`;
      contexto.textAlign = "center";
      contexto.textBaseline = "top";
      contexto.fillText(membro.grauParentesco || "", pos.x + pos.tamanho / 2, pos.y + 2);
      contexto.font = `${14 / visao.escala}px Arial`;
      contexto.textBaseline = "middle";
      contexto.fillText(membro.nome, pos.x + pos.tamanho / 2, pos.y + pos.tamanho / 2);
    }

    // Arraste e zoom com Snap-to-Grid (gridSize = 20)
    let membroArrastando = null;
    let deslocamentoArraste = { x: 0, y: 0 };
    let arrastandoGrade = false;
    let inicioArrasteGrade = { x: 0, y: 0 };
    let deslocamentoInicialVisao = { deslocamentoX: 0, deslocamentoY: 0 };

    elementoCanvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const mx = e.offsetX, my = e.offsetY;
      const antes = obterCoordenadasMundo(mx, my);
      if (e.deltaY < 0) visao.escala *= 1.1;
      else visao.escala /= 1.1;
      visao.deslocamentoX = mx - antes.x * visao.escala;
      visao.deslocamentoY = my - antes.y * visao.escala;
      desenharTudo();
      salvarEstado();
    });

    elementoCanvas.addEventListener("mousedown", tratarInicio);
    elementoCanvas.addEventListener("touchstart", tratarInicio);
    elementoCanvas.addEventListener("mousemove", tratarMovimento);
    elementoCanvas.addEventListener("touchmove", tratarMovimento);
    elementoCanvas.addEventListener("mouseup", tratarFim);
    elementoCanvas.addEventListener("touchend", tratarFim);
    elementoCanvas.addEventListener("touchcancel", tratarFim);

    function obterCoordenadasPonteiro(e) {
      const retangulo = elementoCanvas.getBoundingClientRect();
      if (e.touches && e.touches.length > 0) {
        return { x: e.touches[0].clientX - retangulo.left, y: e.touches[0].clientY - retangulo.top };
      }
      return { x: e.offsetX, y: e.offsetY };
    }
    
    function obterCoordenadasMundo(mx, my) {
      return {
        x: (mx - visao.deslocamentoX) / visao.escala,
        y: (my - visao.deslocamentoY) / visao.escala
      };
    }



    function tratarInicio(e) {
  e.preventDefault();
  const ponteiro = obterCoordenadasPonteiro(e);
  const posMundo = obterCoordenadasMundo(ponteiro.x, ponteiro.y);
  const mx = posMundo.x, my = posMundo.y;

  // 1) Verifica clique no "+" superior
  for (let membro of membros) {
    if (membro.somenteLink) continue;
    const pos = membro.posicaoTela;
    const metade = pos.tamanho / 2;
    if (membro.grauParentesco.toLowerCase() === linhaPai[linhaPai.length - 1]) continue;
    if (membro.grauParentesco.toLowerCase() !== "eu" && membro.grauParentesco.toLowerCase() !== "irmao" &&
        membro.conexoes.some(con => con.direcao === "topo")) continue;
    if (clicouNoMais(mx, my, pos.x + metade, pos.y - distanciaDeslocamento)) {
      // Para "irmão", não exibir '+' superior.
      if (membro.grauParentesco.toLowerCase() === "irmao") continue;
      mostrarModalAdicionar(membro, "topo");
      return;
    }
    
    // 2) Verifica clique no sinal inferior (para adicionar descendentes)
    // Só executa se o membro NÃO for "neto"
    if (membro.grauParentesco.toLowerCase() !== "neto") {
      // Se o membro for "primo", aumenta a área de clique em 5 pixels
      if (membro.grauParentesco.toLowerCase() === "primo") {
        if (clicouNoMais(mx, my, pos.x + metade, pos.y + pos.tamanho + distanciaDeslocamento + 5)) {
          mostrarModalAdicionar(membro, "baixo");
          return;
        }
      } else {
        if (clicouNoMais(mx, my, pos.x + metade, pos.y + pos.tamanho + distanciaDeslocamento)) {
          mostrarModalAdicionar(membro, "baixo");
          return;
        }
      }
    }
    
    // 3) Verifica cliques laterais: somente para "Eu"
    if (membro.grauParentesco.toLowerCase() === "eu") {
      if (clicouNoMais(mx, my, pos.x - distanciaDeslocamento, pos.y + pos.tamanho / 2)) {
        mostrarModalAdicionar(membro, "esquerda");
        return;
      }
      if (clicouNoMais(mx, my, pos.x + pos.tamanho + distanciaDeslocamento, pos.y + pos.tamanho / 2)) {
        mostrarModalAdicionar(membro, "direita");
        return;
      }
    }
  }

  // 4) Verifica se clicou no quadrado para arrastar
  for (let i = membros.length - 1; i >= 0; i--) {
    const membro = membros[i];
    if (membro.somenteLink) continue;
    const pos = membro.posicaoTela;
    if (pontoDentroRetangulo(mx, my, pos.x, pos.y, pos.tamanho, pos.tamanho)) {
      membroArrastando = membro;
      deslocamentoArraste.x = mx - pos.x;
      deslocamentoArraste.y = my - pos.y;
      return;
    }
  }
  
  // 5) Se não foi clique em membro, trata como arraste da grade
  arrastandoGrade = true;
  inicioArrasteGrade = { x: ponteiro.x, y: ponteiro.y };
  deslocamentoInicialVisao = { deslocamentoX: visao.deslocamentoX, deslocamentoY: visao.deslocamentoY };
}

    function tratarMovimento(e) {
      e.preventDefault();
      const ponteiro = obterCoordenadasPonteiro(e);
      if (membroArrastando) {
        const posMundo = obterCoordenadasMundo(ponteiro.x, ponteiro.y);
        let novoX = posMundo.x - deslocamentoArraste.x;
        let novoY = posMundo.y - deslocamentoArraste.y;
        novoX = Math.round(novoX / gridSize) * gridSize;
        novoY = Math.round(novoY / gridSize) * gridSize;
        membroArrastando.posicaoTela.x = novoX;
        membroArrastando.posicaoTela.y = novoY;
        desenharTudo();
      } else if (arrastandoGrade) {
        const dx = ponteiro.x - inicioArrasteGrade.x;
        const dy = ponteiro.y - inicioArrasteGrade.y;
        visao.deslocamentoX = deslocamentoInicialVisao.deslocamentoX + dx;
        visao.deslocamentoY = deslocamentoInicialVisao.deslocamentoY + dy;
        desenharTudo();
      }
    }

    function tratarFim(e) {
      e.preventDefault();
      if (membroArrastando || arrastandoGrade) {
        salvarEstado();
      }
      membroArrastando = null;
      arrastandoGrade = false;
    }

    function pontoDentroRetangulo(px, py, cx, cy, largura, altura) {
      return px >= cx && px <= cx + largura && py >= cy && py <= cy + altura;
    }
    
    function clicouNoMais(mx, my, cx, cy) {
      const dx = mx - cx;
      const dy = my - cy;
      const distancia = Math.sqrt(dx * dx + dy * dy);
      return distancia <= 10;
    }

    carregarEstado();
    desenharTudo();
  </script>
</body>
</html>
